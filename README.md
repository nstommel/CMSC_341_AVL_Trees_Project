# CMSC_341_AVL_Trees_Project
This project implements self-balancing Adelson-Velsky Landis (AVL) trees, which are an extension of a binary search tree, which enforces that the heights of the two child subtrees of any node differ by at most one. If this rule is violated, the tree is rebalanced and the AVL tree property is restored. AVL trees of different types can be stored in a vector in an AVLForest using the wrapper class AVLTreeBase. To use this program, type `/Driver.out <inputfile> <rangefile>` where inputfile is a file like input1.txt and rangefile is a file like range1.txt

# Assignment Prompt
A Binary Search Tree (BST) is a binary tree which maintains an ordering between nodes. While the height of a BST is O(log(n)) on average (for n elements), this is not guaranteed. In the worst case, the elements are inserted in ascending or descending order. In that case, the insert/search/delete operations have complexity O(n) (and that makes us sad). An Adelson-Velsky Landis (AVL) tree is an extension of a BST, which enforces that the heights of the two child subtrees of any node differ by at most one. If this rule is violated, the tree is rebalanced and the AVL tree property is restored. Rebalancing is implemented using tree rotations. In doing so, the worst case complexities for insert/search/delete operations become O(log(n)) (and that makes us happy!). 

Also remember that a double rotation is just a combination of two single rotations. For a given sequence of insertions, there is a fixed sequence of rotations and the resultant tree is therefore unique. Additionally, one rotation (whether single or double) is all that is needed to rebalance after an insertion causes an imbalance. Rebalancing is therefore O(1) time. In this project, we insert <character, number> pairs into an AVL tree, sorted by the number. If the AVL tree is implemented correctly, the corresponding characters will get sorted in a particular order. A traversal of the tree will then spell out a word (printing an AVL tree / node in an AVL tree may be overloaded to do so). In a similar case, the AVL tree may correspond to <word, number> pairs, resulting in an AVL tree corresponding to a sentence. The AVL trees are therefore to be templated for use with inputs as <T, number>. The numbers can further be evaluated as integers or floats, which would also allow the “number” field to be templated. So we now have the AVL tree templated as <T1,T2>. For simplification, there will be consistency of data types among all the insertions for a given AVL tree. The traversal requirement for an AVL tree may be in-order, pre-order, post-order or level-order based on specification for the AVL tree.

Printing the AVL tree with the specified order then allows for a form of “encrypted” message passing mechanism (with a poor level of security, but it’s something  ̄\_(ツ)_/ ̄ ). For consistency of print order, the following enumerator is mandated to be used (included in given code): enum PrintOrder{IN, PRE, POST, LEVEL}; Data will be read from an input stream (file), which will correspond to an unknown number of AVL trees to be created and traversed, each with their own <T1, T2> pairs and print order requirements. Similar to a real-time data source, all inputs for a given tree may not occur in a single block in the input file; inputs across AVL trees may be interleaved in the input file (see example).

An input file will contain the first entry for any tree of the format:
<AVL tree ID,order of printing(enum),data type (enum),number type (enum)>
All following entries for the tree will then be present in the format:
  <AVL tree ID,T1,T2>
A tree ID is a unique positive integer identifier for the tree. For a given AVL tree, all input entries
will have consistent AVL tree ID and print order. They will also be consistent on data type
instantiations of T1 and T2 (for example, all entries will use strings and integers). All numerical
values used (integers and/or floats) will be positive. For simplicity, they will also be unique.
